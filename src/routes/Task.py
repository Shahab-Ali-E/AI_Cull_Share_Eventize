from fastapi import APIRouter,Request
from dependencies.user import get_user
import asyncio
import json
from Celery.utils import get_task_info
from sse_starlette.sse import EventSourceResponse

router = APIRouter(
    tags=['Task Status'],
)


@router.get("/task_status/{task_id}")
async def get_task_status(request:Request,task_id: str):
    """
    ğŸ”„ **Retrieve the Status of a Background Culling Task** ğŸ”„

    This endpoint allows you to check the current status of a background culling task using its unique task ID. The status is streamed to you in real-time via Server-Sent Events (SSE), keeping you updated as the task progresses.

    ### Parameters:
    - **`task_id`** ğŸ†”: The unique ID of the culling task whose status you want to check.
    - **`request`** ğŸ§¾: The request object used to manage connection status.
    - **`user`** ğŸ‘¤: The user making the request, provided through dependency injection.

    ### Responses:
    - âœ… **200 OK**: Real-time updates on the task's status are successfully streamed to the client.
    - â“ **404 Not Found**: The specified task ID does not exist.
    - âš ï¸ **500 Internal Server Error**: An unexpected error occurred while retrieving the task status.
    """
    # Define an asynchronous function that generates events based on the state of a task.
    async def event_generator(task_id):      
        
        # Infinite loop to continuously check the task status and yield events.
        while True:          
            # Check if the client has disconnected from the request. If disconnected, stop the loop.
            if await request.is_disconnected():
                break         
            try:
                # Retrieve the task information and attempt to serialize it
                task_info = get_task_info(task_id=task_id)
                yield {
                    "event": "message",
                    "data": json.dumps(task_info)  # JSON-encoded task information
                }
                # Stop the event stream if the task is completed or failed
                if task_info['state'] in ['FAILURE', 'SUCCESS']:
                    break
            
            except TypeError as te:
                # Catch serialization issues and provide a readable message
                yield {
                    "event": "error",
                    "data": f"Serialization error: {str(te)}. Check data types in task_info."
                }
                break  # Stop further streaming on error
            except Exception as e:
                # Handle unexpected errors
                yield {
                    "event": "error",
                    "data": f"Unexpected error: {str(e)}"
                }
                break

            await asyncio.sleep(2)
                

    # Return an EventSourceResponse, which continuously streams events generated by event_generator.
    return EventSourceResponse(event_generator(task_id))
