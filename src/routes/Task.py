from fastapi import APIRouter,Request
from fastapi.responses import JSONResponse
from sqlalchemy import MetaData, Table, select
from dependencies.core import DBSessionDep
from dependencies.user import get_user
import asyncio
import json
from Celery.utils import get_task_info
from sse_starlette.sse import EventSourceResponse

router = APIRouter(
    tags=['Task Status'],
)


@router.get("/task_status/{task_id}")
async def get_task_status(request:Request,task_id: str, db_session:DBSessionDep):
    """
    ğŸ”„ **Retrieve the Status of a Background Culling Task** ğŸ”„

    This endpoint allows you to check the current status of a background culling task using its unique task ID. The status is streamed to you in real-time via Server-Sent Events (SSE), keeping you updated as the task progresses.

    ### Parameters:
    - **`task_id`** ğŸ†”: The unique ID of the culling task whose status you want to check.
    - **`request`** ğŸ§¾: The request object used to manage connection status.
    - **`user`** ğŸ‘¤: The user making the request, provided through dependency injection.

    ### Responses:
    - âœ… **200 OK**: Real-time updates on the task's status are successfully streamed to the client.
    - â“ **404 Not Found**: The specified task ID does not exist.
    - âš ï¸ **500 Internal Server Error**: An unexpected error occurred while retrieving the task status.
    """
    # #  Reflect the Celery result table
    # metadata = MetaData()
    # celery_meta = Table(
    #     'celery_taskmeta',
    #     metadata,
    #     autoload_with=db_session.bind
    # )
    # stmt = (
    #     select(celery_meta.c.task_id,
    #            celery_meta.c.status,
    #            celery_meta.c.result)
    #     .where(celery_meta.c.task_id == task_id)
    # )
    # row = db_session.execute(stmt).first()

    # # 32 If already finished, send immediate JSON
    # if row:
    #     return JSONResponse({
    #         'state': row.status,
    #         'status': (
    #             'Task completed successfully.'
    #             if row.status == 'SUCCESS'
    #             else f'Task ended with status: {row.status}'
    #         ),
    #         'result': row.result
    #     })
    # Define an asynchronous function that generates events based on the state of a task.
    async def event_generator(task_id):      
        
        # Infinite loop to continuously check the task status and yield events.
        while True:          
            # Check if the client has disconnected from the request. If disconnected, stop the loop.
            if await request.is_disconnected():
                break         
            try:
                # Retrieve the task information and attempt to serialize it
                task_info = get_task_info(task_id=task_id)
                yield {
                    "event": "message",
                    "data": json.dumps(task_info)  # JSON-encoded task information
                }
                # Stop the event stream if the task is completed or failed
                if task_info['state'] in ['FAILURE', 'SUCCESS']:
                    break
            
            except TypeError as te:
                # Catch serialization issues and provide a readable message
                yield {
                    "event": "error",
                    "data": f"Serialization error: {str(te)}. Check data types in task_info."
                }
                break  # Stop further streaming on error
            except Exception as e:
                # Handle unexpected errors
                yield {
                    "event": "error",
                    "data": f"Unexpected error: {str(e)}"
                }
                break

            await asyncio.sleep(2)
                

    # Return an EventSourceResponse, which continuously streams events generated by event_generator.
    return EventSourceResponse(event_generator(task_id))
